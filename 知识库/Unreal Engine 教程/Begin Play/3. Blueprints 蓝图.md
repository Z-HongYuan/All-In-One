# Blueprints 蓝图

![[Blueprint.png]][官方视频](https://dev.epicgames.com/community/learning/tutorials/ryZ7/unreal-engine-begin-play-blueprints?source=0w)

从高层次上概述虚幻引擎中的 Blueprint 可视化脚本系统，并研究它在整个引擎中的实现和结构。

可视化脚本系统用于更方便的取代例如 `C`#, `js` 等语言.更利好设计师

**材质和 `Niagara` 系统有自己的工作流程, 但是接近于蓝图**

# 总结

**`Unreal Engine` 的一切基于 `C++`**

- 蓝图主要在 `C++` 层与编辑器层中作为接入层.
程序员可以轻松的通过蓝图来公开 `C++` 的功能

- 可以只使用蓝图构建简单的游戏.
其中蓝图提供了许多基建, 例如 `DataAsset` , `Gameplay` 框架

- 蓝图由一个快速的虚拟机编译和运行

- 蓝图也拥有调试和分析工具, 能够在牺牲一部分性能的情况下进行调试和分析.
在开发模式下和发布模式下的蓝图性能最佳

- 蓝图在引擎中被视为内容资产, 适用于资产相关的加载和引用

# 依赖可视化的工作流程

- 其他脚本和蓝图资产
	1. `Blueprint Classes` **(蓝图类)**
		- 用于扩展逻辑
		- 创建自定义游戏对象
		- 作为自定义预制件等等
	2. `Level Blueprint` **(关卡蓝图)**
		- 用于每个关卡的特定逻辑
	3. `Sequencer` **(序列)**
		- 过场动画工具, 虽然使用的是关键帧, 但是可以通过轨道的事件通知来调用蓝图中的函数
	4. `UMG` **界面**
		- 使用可视化的界面设计 `UI`, 并且使用蓝图来控制逻辑
	5. `Anim Blueprint` **动画蓝图**
		- 控制和混合骨骼中的数据, 还有状态机
		- 其中使用了传统的蓝图, 也包含有其专用的动画混合节点
	6. `Control Rig` **控制绑定**
		- 通过各种控制器或者后期解算器来驱动骨骼网格体
		- 能创建程序化动画, 或者直接在编辑器中制作动画序列
	7. `Materials` **材质**
		- 使用可视化的节点快速实现外观和效果
		- 包含许多材质模型, 包含但不限于: 表面, 后期处理, 用户界面等等
	8. `Niagara` **粒子系统**
		- 模拟粒子和视觉特效的框架
		- 通过空间脚本语言创建数据处理模块
	9. `MetaSound` **音频系统**
		- 使用可视化脚本系统
		- 高性能, 高精度等优点
	10. `Behavior Trees` **行为树**
	11. `Environment Query` **场景查询**
	12. **More and More**

# 蓝图继承于 `C++`

可以使用 `C++` 对蓝图进行拓展
蓝图是强类型语言, 需要识别数据类型

在 `C++` 中公开变量或者函数到蓝图很容易.
在蓝图中的变量或者函数公开到 `C++` 很难
**总结 `C++`->`Blueprint` 容易, `Blueprint`->`C++` 很难**

> **蓝图支持引擎的高级功能:**
> 1. 实例编辑
> 2. 网络复制
> 3. 保存文件序列化
> 4. 等等

> **蓝图还拥有完整的流控制节点**
> 1. 分支 (`IF`, `Switch` 等等)
> 2. 循环 (`基础 For`, `迭代器 For`, 等等)
> 3. 特殊功能 (`Gate(门)`, `DoOnce`, `Sequence(序列)`, 等等)

> 使用 `C` 键添加注释, 以及在各个说明框中填入注释或者说明框

![[Pasted image 20250521174736.png]]
还可以使用蓝图继承基于 `C++` 的框架类:
1. `Actor` & `Anymore` 基于 `Actor` 的基础类
2. `GameMode` 游戏模式
3. `GameInstance` 游戏实例
4. `Controller` 控制器
5. `Pawn` 棋子
6. `GameState` 游戏状态
7. `PlayerState` 玩家状态
8. `AIController` AI 控制器
9. `PlayerController` 玩家控制器
10. `Character` 角色
11. `Spectator` 旁观者

# 蓝图编辑器

包含一个及以上的图表, 还有大量数据
蓝图不支持源码管理, 但是 `UE` 支持 `Diff` 工具

## `Function`

蓝图函数类似于传统语言的函数
- 拥有接收数据和返回数据的功能
- 在一帧中执行代码

## `Event`

蓝图事件
- **不能返回数值**
- **支持潜在执行 (不是异步, 类似于协程, 伪协程序)**

## `Macros`

蓝图宏
- 一组可以重复使用的节点
- **会在编译期间自动展开宏的完整形式**
- 对于性能敏感的地方, **优先使用函数**

## `事件分发器`

适用于在蓝图中通信, **管理大量对象之间的通信**
在订阅事件后, 触发分发器, 那么就会收到通知

## `函数库和宏库`

独立类
通过引用调用静态函数

# 数据功能

- `曲线资产`
	独立的数据资产,
	通过输入值驱动输出的数据

- `数据结构`
	简化的蓝图资产~~, 纯数据蓝图~~
	只包含变量

- `DataTables`(数据表)
	类似于电子表格
	可以定义一个数据结构, 然后根据这个数据结构来添加列
	能导入/导出, 用外部数据更新等方便功能

**还有其他许多的数据资产, 还可以使用蓝图或者 `C++` 创建自己想要的数据资产**

# `Actor`

可以在编辑器中放置, **也可以通过代码在运行时生成**

`Actor` 蓝图可以使用组件
一般是通过组件组合成一个特定的 `Actor`

可以附加子 `Actor`, 当做组件处理

> 场景组件
> **光源和 * 网格体 * 等组件, 通常继承自场景组件**
> 例如项目中的淡化 `Mesh`

> `Actor` 组件:
> **`Actor` 组件更为抽象, 不支持变换**
> 可以用来为 `Actor` 提供模块化行为, 例如寻路或者自动移动等功能

## 生命周期

`Actor` 拥有内置事件, 协助管理生命周期, 例如:
- `BeginPlayer Event` 开始事件
- `Destroy Event` 销毁事件

## 构造脚本

用于初始化 `Actor` 的首选方法
**构造脚本会在 `Actor` 修改变量的时候在编辑器自动运行**

## `Tick` 事件

`Tick` 会在每帧调用, 如果需要不断更新则使用 `Tick` 函数

**UE 支持可变刷新率所以需要使用场景差量来增量计算位移等数值**

## `Timer` 定时器

使用定时器来优化 `Tick` 或者延时之类的逻辑

## `Timeline` 时间轴

内部使用曲线资产, 或者内部曲线编辑器.
支持运行时播放, 停止, 翻转等流程控制
**在每次更新时, 返回当前每条曲线的值**

# 蓝图扩展编辑器

能够执行常规任务

## 使用 UMG 构建编辑器控件

自定义在编辑器内的控件, 用于特定事情或者执行某些逻辑
通常用于, **自动化一些繁琐的制作任务**

## 操作实用工具

能够拓展右键菜单
对选中的一组对象上执行任务
可以在关卡中, 也可以在内容浏览器中

## 编辑器实用工具

在后台被动运行, 可以监听事件, 执行资产验证检查之类的任务

## 执行控制台命令

在蓝图中有节点, 能够执行控制台命令和运行 `Python` 代码
可以用于调试引擎性能, 或者映射一些复杂的命令

# 蓝图通信

> 蓝图通信能对性能造成很大的影响

> 因为蓝图被视为内容资产
所以在加载等性能方面, 会导致一次加载较多的数据到内存中

> **建议使用软引用变量而不是默认硬引用**来延迟加载数据
资产软引用要确保加载成功才能使用

> 在继承的时候, 蓝图继承会把父类的所有引用加载, 所以**确保中间蓝图 (清理中间蓝图的引用)** 未拥有任何子类蓝图不需要的引用, 或者把父类标记为抽象类

> **类型转换是另一种隐形硬引用的方式**也会导致固定加载
> 建议:
> 1. 基础代码移植到 `C++` 上, 因为 `C++` 速度快而且引用少, 在游戏启动的时候就会被加载
> 2. 使用蓝图接口
> 3. 使用事件分发器

# 蓝图分析和调试工具

- `Print`(打印节点)
- `Draw Debug Nodes`(绘制调试节点)
- 在 PIE 运行时, 在蓝图编辑器内选择蓝图实例即可查看调试
- 可以在节点上设置断点, 然后分步推进
- 可以在 `BlueprintDebug` 窗口中, 查看调试信息和调用堆栈
- 可视记录器, 用于记录一段时间内多个对象发生的复杂交互行为, 并且把事件记录到时间轴上
- 在蓝图内编写单元测试, 然后通过 UE 的自动化框架执行

在大量修改 `C++` 代码后使用**强制编译所有蓝图**的选项, 可以清除隐含的问题
