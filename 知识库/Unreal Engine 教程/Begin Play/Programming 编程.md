# Programming 编程

![[Programming.png]]

[官方视频](https://dev.epicgames.com/community/learning/tutorials/lMr9/unreal-engine-begin-play-programming?source=0w)

从高层次概述如何开始使用虚幻引擎进行编程。

1. # 汇总

**源代码是 UE 的核心**

使用 C++ 编码

所有 C++ 代码都是模块化 `Modules` 的, 包括虚幻引擎源码

**编译代码时, 用到 `UBT(UnrealBuildTool)`****跨平台构建系统进行编译, 由 C#编写**

宏可以公开给蓝图和编辑器包括但不限于如下宏

| `UClass` | `UStruct` | `UEnum` | `UFunction` | `UProperty` |
| -------- | --------- | ------- | ----------- | ----------- |

`UClass`, `UStruct`, `UEnum` 用于向编辑器公开类型, 适用于蓝图也适用于编辑器

`UProperty` 用于向虚幻引擎公开类成员, 适用于蓝图和细节面板, 可以定义查看, 访问, 编辑等属性

实现对象指针的自动内存管理, 联网, 序列化等功能

**所有引用****`UObject`****的类属性, 必须是****`UProperty`****引用, 或是****`弱指针类型`**

![[Pasted image 20250425214514.png]]

作用是在垃圾回收后, 再次引用指针不会崩溃

**`UFunction` 向虚幻引擎公开函数**

虚幻引擎不使用来自 C++ 的标准库, 而是自己构建一套有利于编辑器集成, 序列化支持, 多平台移植等功能

**数字类型有: 支持蓝图和复制**

- `Float`
    
- `Double`
    
- `[U] int8|16|32|64`

**创建****`Enums`****(枚举) 公开给引擎**

**创建****`Struct`****(结构体) 和类相似, 只不过需要保存普通数据, 不能应用任何蓝图函数**

**字符串类型有: 支持蓝图和复制**

- `FString` 标准普通字符串, 可变的宽字符数组封装器
    
- `FName` 在全局映射中散列并缓存字符串, 然后从 FNamed 变量引用, 只存储字符串索引, 用于更快的性能, 不区分大小写, 最适用于名称和路径
    
- `FText` 包含内置本地化支持的字符串, 由引擎的本地化系统收集来翻译, 用于面对用户的文本, 例如 UMG 的用户界面

**集合类型有: 支持蓝图和复制**

- `TArray` 数组
    
- `TMap` 映射
    
- `TSet` 集合

**变换类型有: 支持蓝图和复制**

- `FVector` 向量
    
- `FRotator` 旋转
    
- `FQuat` 四元数
    
- `FTransform` 变换

如果需要修改引擎源码, 最好是把项目和引擎放在一起, 这样项目会变成原生项目与引擎自动关联

建议编码时, 使用模块化的编码规则, 尽可能分类模块

插件是模块和资产的集合, 模块整合进插件内，可以使得在平台之间共用。

`UAT(UnrealAutoTool)` 虚幻自动化工具, 用于打包, 烘焙或者其他可能需要自动化的流程

## **UObject:**

是最底层的虚幻引擎对象, 内存由 UE 管理, 所有扩展类应该添加**前缀 U**

只能使用 `NewObject<Object>` 函数分配新的 `UObject`

`UObject` 会在没有任何引用的时候自动销毁

## **Actor:**

是放在关卡的任意对象, 扩展类应该添加**前缀 A**

`Actor` 会跟随父项关卡自动加载和销毁, 也可以使用 `Destroy` 函数进行销毁

还可以通过 `Components` 组件添加新功能, 父项 `Actor` 类似于 `Component` 的容器

`Component` 组件可以是 `AActor`, `UScene`

只能使用 `SpawnActor<Actor>` 函数分配 `Actor`

最终由垃圾收集器释放内存

## **指针:**

![[Pasted image 20250425214743.png]]

`UObject` 跟踪负责左边, 非 UObject 跟踪负责右边

不要在 UObject 中使用右边的指针

## **Interface:**

**接口可以在不相关的类里面实现可选函数**

UE 里面, 任何类都可以调用接口, **但是只有函数拥有实现的时候, 函数才会调用**

接口可以在 C++ 中或者蓝图中声明, **建议在 C++ 中创建接口**

## **StaticFunctionLibrary****:**

静态函数库可以创建在任何地方调用的静态函数

很合适为结构体添加功能

## **Data Object:**

数据对象提供一种组织和加载数据的方法, 是一种通用容器, 类似于纯数据蓝图

拥有简单的导入导出功能, 并且支持虚幻类型

- Data Asset
    
- Data Table
    
- Curve

## **Delegate & Event:**

委托和事件

可以在 C++ 或者蓝图中创建

## Subsystem

子系统, 可以在任何地方访问

## Async Task

异步任务, 由引擎管理, 用于在 CPU 中多个内核上运行, 或者用于异步线程工作

内部使用了线程池

## 内存

资产可以通过地图加载, 也可以通过请求软引用加载一个对象

对象会在没有任何引用的时候通过垃圾收集器卸载

硬引用会随着父项资产自动加载

**建议使用软引用或者接口, 以减少硬性依赖**

垃圾收集器包括没有引用的对象或者等待销毁的对象, 其中使用标记 - 清除法

标记和清除是重度多线程任务, 发生在一帧内, 而事实上的对象销毁使用时间切片在多个帧上运行

2. # Gameplay 框架

建议使用 Gameplay 框架, 而不是自己设计系统

# `GameMode`

是每个关卡都有的对象, 定义了关卡的规则, 比如生成什么 Pawn, HUD 等.

对多人游戏, GameMode 实例只存在于服务器中, 定义了会话规则, 谁可以加入, 旁观者规则等等

会在切换关卡时被销毁, 不适合存储永久数据

# `GameInstance`

游戏实例, 每个客户端都有一个贯穿整个应用生命周期的游戏实例

全局单例, 可以从任何地方访问.

也可以创建一个 `GameplaySubsystem` 游戏实例子系统, 类似于 `GameInstance` 的组件

# `GameState`

游戏状态是一个会从服务器复制到所有客户端的对象

用于跟踪游戏状态例如游戏暂停等, 还会保存 `PlayerState`

# `PlayerState`

特定于指定玩家的游戏信息, 会从服务器复制到所有客户端

存储玩家名称, 分数, Ping 等数据

# `Pawn`/`Character`

玩家可以控制的角色

默认除了复制不含其他内容

`Character` 是一种特殊的 Pawn, 包含一个 `CMC移动组件` 一个 `SkeletalMesh骨骼网格体`

# `Controller`

`Pawn` 由 `Controller` 控制器控制, 可以是 AI 控制, 也可以是玩家控制, 可以在游戏过程中随时切换

用于处理输入和命令, 然后发送给 `Pawn`, 用于控制 `Pawn`

每个玩家控制器都与玩家状态下的特定玩家相关联.

玩家控制器只存在于拥有的客户端和服务器上, 玩家控制器允许客户端与服务器通信

**建议在****`Controller`****中处理所有的输入, 而不是在****`Pawn`****中, 容易 AI 和玩家控制相互切换**

# `InputComponent`

输入组件处理输入, 在每个控制器中都有

输入组件会将输入命令和游戏功能绑定

**请使用增强输入组件**

# `MovementComponent`

移动组件会将用户输入转换成游戏内的移动, 负责复制

会尝试预测移动, 会导致滞后

移动组件有很多类型, 例如发射器, 插值, Pawn, Character, 载具.可以扩展以实现自定义移动

# `CheatManager`

作弊管理器用于开发作弊和调试命令, 在玩家控制器中设置使用的作弊类

会在发布版本中添加, 是一种安全调试方法

# `Tick系统`

每个 Actor 和组件都可以注册 Tick, 可以在 UObject 中添加 Tick

Tick 拥有不同的 Tick 群, 例如在物理模拟之前, 在物理模拟期间

如果没有使用转换或者碰撞, 最好选择在物理模拟期间 Tick

可以定义 Tick 率, Tick 依赖, 逐个对象启用/禁用 Tick

**Tick 是单线程运行, 可能是游戏的一个常用阻塞点, 请考虑 Tick 的使用时机**

# `GameplayAbilitySystem`

模块化, 支持复制, 稳健的方式处理玩家玩法技能等

# `Mass`

允许通过分布式执行和状态图表来定义和管理大量的游戏实体

# `GameFeature`

游戏功能插件允许在运行的时候安全的启用或者禁用功能

让项目定义游戏功能, 而不是游戏功能定义项目, 所有允许项目对游戏功能不可知

游戏功能插件会注册到游戏中, 通常可以在运行中向对象添加组件来扩展游戏玩法功能, 但还可以通过调用函数, 接口等实现深度集成游戏功能

3. # 网络支持

基于 Client-Server 的网络架构

服务器可以是另一个游戏实例或者专用服务器运行无 HUD 的应用程序

负责每个平台上的会话, 链接, 通信.

`Actor` 可以通过复制选项轻松复制到所有客户端, 可以标记想要复制的每个属性

`RepNotify` 允许在复制变量的值发生变化时做出反应, 执行逻辑

网络中, 遵循所有权的概念, 只有玩家控制器拥有的 Actor, 才能向服务器发送数据.而服务器可以将数据发送给每个人

UE 有 `ReplicationGraph`(复制图) 插件, 用于设置 Actor 和其他玩家客户端产生关联的规则.例如距离, 可见性, 或者其他属性

`RPC` 远程过程调用, 允许在不同的客户端上调用函数.可以使用标记可靠/不可靠来确保能成功调用

4. # 调试/分析

## Log 日志

C++ 中使用 `UE_Log` 宏或者蓝图中使用 `Print` 节点

## 可视化记录器

把事件在一个轴上, 用于复现内容, 支持网络复制记录

使用接口或者事件轻松设置, 对于 AI 记录十分有用

## 内置控制台

会在发布版本中编译出来

可以触发控制台命令, 或者修改控制台变量的值

## Unreal Insights 分析工具

分析很多数据, 适用于编辑器, 也使用与打包版本

例如 CPU, TPU, 内存分配, 网络

支持保存和回放分析数据, 支持远程分析

## ~~CSV Profiler~~

CSV 分析器, 输出的数据可以整合到一个图表中, 用于帧计时

## ~~Low Level Memory~~

LLM 根据内存分配的堆栈, 为每个内存分配提供一个标记 建议使用 `Insights`

## ProfileGPU

控制台命令, 可以用来检查一帧的计时

## DumpGPU

可以转储单个帧的所有内部资源

以 HTML 页面形式进行检查

## Gauntlet

运行构建版本和验证结果的框架

目的是为了在多平台上实现自动运行

非常适合自动化测试, 例如生成一个服务器, 链接多个客户端
