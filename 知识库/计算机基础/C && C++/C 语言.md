# C 语言

关联 [[C++ 语言]]

## C 程序结构 (基础)

> - 预处理器指令
> - 函数
> - 变量
> - 语句 & 表达式
> - 注释

## C 基本语法

> - 有且只有一个 main 函数 - 程序的入口
> - 标识符 (取名) 区分大小写, 不允许出现标点字符
> - 注释 (不能嵌套)
> - //单行注释
> - /\* str \*/多行注释
> - 关键字
> - 转义字符

---

# 数据类型

## 基本数据类型

> - char(字符型)
> - int(整形)
> - short(短整型)
> - long(长整型)
> - float(单精度)
> - double(双精度)(默认)
> - …..

## 枚举类型

> - 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量

## Void 类型

> - 类型说明符 void 表示没有值的数据类型，通常用于函数返回值

## 派生类型

> - 包括数组类型、指针类型和结构体类型

## 构造类型 (自定义类型)

> - 数组类型
> - 结构体类型
> - 枚举类型
> - 联合类型

## 类型转换

> 可能会导致数据精度丢失或数据截断
> - 隐形 表达式中自动发生
> - 显形 使用强制类型转换运算符

## 常量变量

> 同名局部变量优先
> - 常量
> - 变量

## 作用域和生命周期

> - 全局: 生命周期为整个程序生命
> - 局部: 生命周期为作用域内

## 有符号数和无符号数

---

# C 存储类

> - 存储类定义 C 程序中变量/函数的存储位置、生命周期和作用域
> - auto
> - register
> - static
> - extern

---

# 运算符

## 算术运算符

| 操作符 | 作用                             |
| :------: | :--------------------------------: |
| +      | 把两个操作数相加                 |
| -      | 从第一个操作数中减去第二个操作数 |
| *      | 把两个操作数相乘                 |
| /      | 把两个操作数相除                 |
| %      | 取模运算符，整除后的余数         |
| ++     | 自增运算符，整数值增加 1         |
| --     | 自减运算符，整数值减少 1         |

## 关系运算符

| 操作符 |                                                              |
| --- | ------------------------------------------------------------ |
| ==  | 检查两个操作数的值是否相等，如果相等则条件为真               |
| !=  | 检查两个操作数的值是否相等，如果不相等则条件为真             |
| >   | 检查左操作数的值是否大于右操作数的值，如果是则条件为真       |
| <   | 检查左操作数的值是否小于右操作数的值，如果是则条件为真       |
| >=  | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真 |
| <=  | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真 |

## 逻辑运算符

|      |                                                                                    |
| ---- | ---------------------------------------------------------------------------------- |
| &&   | 称为逻辑与运算符。如果两个操作数都非零，则条件为真 (同真为真)                      |
| \|\| | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真 (有真为真)(同假为假)  |
| !    | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 |

## 位运算符

- 位运算符作用于位，并逐位执行操作

| 运算符 | 名称       | 示例    | 说明                                                |
| ------ | ---------- | ------- | --------------------------------------------------- |
| &      | 按位与     | a & b   | 对应位都为 1，结果才为 1                            |
| \|     | 按位或     | a       |                                                     |
| ^      | 按位异或   | a ^ b   | 对应位不同为 1，相同为 0                            |
| ~      | 按位取反   | ~       | 所有位翻转，0 变 1，1 变 0                          |
| <<     | 左移       | a << n  | 所有位向左移动 n 位，右侧补 0（乘以 2 的 n 次方）   |
| >>     | 有符号右移 | a >> n  | 所有位向右移动 n 位，保留符号位（除以 2 的 n 次方） |
| >>>    | 无符号右移 | a >>> n | 所有位右移，左侧补 0（JavaScript/Java 特有）        |

## 赋值运算符

|     |                                                                                           |
| --- | ----------------------------------------------------------------------------------------- |
| =   | 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C          |
| +=  | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A  |
| -=  | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A  |
| *=  | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C \*= A 相当于 C = C * A |
| /=  | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A  |
| %=  | 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A                |
| <<= | 左移且赋值运算符 C <<= 2 等同于 C = C << 2                                                |
| >>= | 右移且赋值运算符 C >>= 2 等同于 C = C >> 2                                                |
| &=  | 按位与且赋值运算符 C &= 2 等同于 C = C & 2                                                |
| ^=  | 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2                                              |
| \|= | 按位或且赋值运算符                                                                        |

## 杂项运算符

|          |                |                                      |
| -------- | -------------- | ------------------------------------ |
| sizeof() | 返回变量的大小 | sizeof(a) 将返回 4，其中 a 是整数。  |
| &        | 返回变量的地址 | &a; 将给出变量的实际地址。           |
| *        | 指向一个变量   | *a; 将指向一个变量。                 |
| ? :      | 条件表达式     | 如果条件为真 ? 则值为 X : 否则值为 Y |

## 优先级

| 优先级 | 运算符                                              | 描述                                                          | 结合性 |
| ------ | --------------------------------------------------- | ------------------------------------------------------------- | ------ |
| 1      | `()` `[]` `->` `.`                                  | 函数调用、数组下标、成员访问                                  | 左到右 |
| 2      | `++` `--` `+` `-` `!` `~` `(type)` `*` `&` `sizeof` | 单目运算、自增、自减、强制类型转换、取地址、解引用、逻辑/位反 | 右到左 |
| 3      | `*` `/` `%`                                         | 乘法、除法、取余                                              | 左到右 |
| 4      | `+` `-`                                             | 加法、减法                                                    | 左到右 |
| 5      | `<<` `>>`                                           | **位移运算符**（左移右移）                                    | 左到右 |
| 6      | `<` `<=` `>` `>=`                                   | 关系运算符（大于、小于等）                                    | 左到右 |
| 7      | `==` `!=`                                           | 相等、不等                                                    | 左到右 |
| 8      | `&`                                                 | **按位与**                                                    | 左到右 |
| 9      | `^`                                                 | **按位异或**                                                  | 左到右 |
| 10     | `\|`                                                | **按位或**                                                    | 左到右 |
| 11     | `&&`                                                | **逻辑与**                                                    | 左到右 |
| 12     | `\|`                                                | **逻辑或**                                                    | 左到右 |
| 13     | `?:`                                                | 三目条件运算符                                                | 右到左 |
| 14     | `=` `+=` `-=` `*=` `/=` `&=` `|= ^= >>= <<=`        | 赋值运算                                                      |        |
| 15     | `, `                                                | 逗号运算符                                                    | 左到右 |

---

# 顺序/选择/循环结构

## 顺序结构 (顺序执行代码)

## 选择结构

> - 选择语句
> 	- if(else 就近匹配原则)
> 	- Switch(多分支)
> 
> - ? : 运算符 (三元运算符)

## 循环结构

> - 循环类型
> 	- for(主要)
> 		- for(;;) 无限循环
> 		- for(允许多个表达式)
> 	- while
> 
> - 循环控制
> 	- break(终止循环)
> 	- continue(跳过本次循环)

---

# 函数

## 库函数

> **" 库函数 "**是指由编程语言或操作系统提供、封装在标准库或外部库中、供开发者直接调用使用的**预定义函数**。

## 自定义函数

### 基本结构

> 1. **返回类型**
> 
> 2. **函数名**
> 
> 3. **函数参数**
> 形参实例化之后其实相当于实参的一份临时拷贝
> 	1. 形参 (形式参数)
> 当实参传给形参的时候形参其实是实参的一份临时拷贝对形参的修改是不会改变实参的
> 	2. 实参 (实际参数)
> 
> 4. **函数主体**

### 函数调用

> 1. **传值调用**
> 	- 向函数传递参数的传值调用方法，把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。
> 	- 函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参
> 
> 2. **传址调用 (引用调用)**
> 	- 通过引用传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。
> 	- 传址调用是把函数外部创建变量的内存地址传递给函数参数的一种调用函数的方式.这种传参方式可以让函数和函数外边的变量建立起正真的联系，也就是函数内部可以直接操作函数外部的变量
> 	- 传递参数为数组时, 传递的只是数组的第一个元素的地址
> 
> 3. **函数的嵌套调用和链式访问**
> 函数和函数之间可以有机的组合
> 	- 嵌套调用
> 	- 链式访问: 把一个函数的返回值作为另外一个函数的参数

### 函数的声明和定义

> 1. **函数声明**
> 	- 告诉编译器有一个函数叫什么，参数是什么，返回类型是什么.但是具体是不是存在，无关紧要
> 	- 函数的声明一般出现在函数的使用之前.要满足先**声明后使用**
> 	- 函数的声明一般要放在头文件中的
> 
> 2. **函数定义**
> 	- 函数的定义是指函数的具体实现，交待函数的功能实现

### 函数递归

> 即函数直接或间接地调用自身
>
> - 需要终止条件, 不然会溢出
> - 存在限制条件，当满足这个限制条件的时候，递归便不再继续
> - 每次递归调用之后越来越接近这个限制条件
> - 指数级增长 O(2^n) 效率低, 可能栈溢出

---

# 指针

> - 指针也就是内存地址，指针变量是用来存放内存地址的变量
> - 符号 *
> - 解引用 *

---

# 数组

## 操作符 [ ]

## 初始化

> - 下标从 0 开始的
> - 不完全初始化, 默认值为 0

## 一维数组

> 连续存放

## 二维数组

> - int arr[x][y]
> - 可以省略行不能省略列 int arr[][y]
> - 连续存放
![[Pasted image 20250430235835.png]]

## 数组传递

> - 数组作为函数参数传递的是首元素的地址
> - &数组名，取出的是数组的地址.
> - &数组名，数组名表示整个数组
> - 除此 1，2 两种情况之外，所有的数组名都表示数组首元素的地址

## Sizeof 操作符计算的是整个数组的大小单位字节

---

# 操作符详解

## 算数操作符

> - `/` 除获得的是商
> - `%` 模获得是余数 必须是整数

## 移位操作符

> 对于移动负数位标准未定义操作数必须为整数补码形式二进制存储

> - `>>` 右移操作符, 移动的是二进制位 a>>1 位
> 算术右移 右边丢弃, 左边补位补的是原符号位基本上是算术右移
> 逻辑右移 右边丢弃, 左边补 0
> 一定程度上相当于除以 2^位

> - `<<` 左移操作符 a<<1 位
> 左边丢弃右边补 0
> 一定程度上相当于乘以 2^位

## 位操作符

> 操作数必须是整数补码形式二进制存储

> - `&` 按位与
> 有 0 则 0, 全 1 才 1

> - `|` 按位或
> 有 1 则 1, 全 0 才 0

> - `^` 按位异或
> 相同为 0, 相异为 1
> 相同的数异或为 0, 任何数和 0 异或是他本身

## 赋值操作符=

## 复合操作符

> 以上符号加=符号组成复合操作符如 +=

## 单目操作符

|                 |                               |
| --------------- | ----------------------------- |
| !               | 逻辑取反                      |
| -               | 负值                          |
| +               | 正值                          |
| (类型)          | 强制类型转换                  |
| *               | 间接访问操作符 (解引用操作符) |
| -- 前置/++ 前置 | 先自运算                      |
| -- 后置/++ 后置 | 后自运算                      |
| ~               | 对一个数的二进制按位取反      |
| sizeof          | 操作数的类型长度占用空间大小  |
| &               | 取地址                        |

## 关系操作符

|     |     |     |
| --- | --- | --- |
| >   | <   | =   |

## 逻辑操作符

|           |                                    |                                                |
| --------- | ---------------------------------- | ---------------------------------------------- |
| && 逻辑与 | 两个都为真才是真, 否则为假         | 长串的表达式内, 出现假, 后面就不用算了就是假了 |
| \| 逻辑或 | 有一个是真就是真, 两个都是假才是假 | 长串的表达式内, 出现真, 后面就不用算了就是真了 |

## 条件操作符

> 三目操作符
> - `exp1` ? `exp2` : `exp3`
> - `exp1` 为真执行 `exp2`; `exp1` 为假执行 `exp3`

## 逗号表达式

> `exp1` , `exp2` , `exp3`, … , `expN`
> - 逗号表达式，就是用逗号隔开的多个表达式.逗号表达式，从左向右依次执行.整个表达式的结果是最后一个表达式的结果
> ![[Pasted image 20250513144722.png]]

## 下标引用、函数调用和结构成员

|                         |                                                                                |
| ----------------------- | ------------------------------------------------------------------------------ |
| 下标引用操作符 `[ ]`    | 操作数: 一个数组名一个索引值                                                   |
| 函数调用操作符 `( )`    | 接受一个或者多个操作数: 第一个操作数是函数名，剩余的操作数就是传递给函数的参数 |
| 访问一个结构的成员 `->` | 结构体 . 成员名 结构体指针 `->` 成员名                                         |

![[Pasted image 20250513145332.png]]

## 显式/隐式类型转换

> - 整形提升
> - 算数转换

## 操作符有优先级

![[Pasted image 20250513150914.png]]

---

# 指针

## 指针是什么

> 总结: 指针就是变量，用来存放地址的变量.(存放在指针中的值都被当成地址处理)
> ![[Pasted image 20250513151139.png]]

## 指针大小

> 2^n 次方个地址, n 为多少位地址线就是多少位系统

## 指针类型

> 决定指针进行解引用操作的时候能够访问空间的大小
> `char*` 只修改了一个字节
> ![[Pasted image 20250513151343.png]]
> - 指针类型决定了：指针走一步走多远 (指针的步长)
> - 总结: 指针的类型决定了指针向前或者向后走一步有多大 (距离)

## 野指针

> - 概念: 野指针就是指针指向的位置是不可知的 (随机的不正确的，没有明确限制的)
> - 造成原因:
> 	1. 指针未初始化
> 	2. 局部的指针变量，就被初始化随机值
> 	3. 实际为修饰符不一样时初始化值不一样
> 	4. auto 时为随机值, static 修饰时为 0
> 	5. 指针越界访问, 比如访问数组的连续空间时指针超过数组范围时, 这个指针就是野指针
> 	6. 指针指向的空间被释放时

> - 如何规避野指针
> 	1. 指针初始化
> 	2. 小心指针越界
> 	3. 指针指向空间释放即使置空
> 	4. 指针使用之前检查有效性

## 指针运算

|                |                                                                                                                                                                                                                                           |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 指针 +- 整数   | 这个操作会移动指针到内存中的其他位置。在 C++ 或 C 语言中，p += i;。指针移动到内存中的位置 i 个单位。例如，如果你有一个指向数组的指针 p，p += 2 将会把 p 移动到数组的第三个元素。                                                          |
| 指针 - 指针    | 如果两个指针指向同一数组或者相同类型的内存块，那么可以通过减法运算来计算它们之间的差值。这个差值表示两个指针之间有多少个元素 结果是一个长整型（long）的数                                                                                 |
| 指针的关系运算 | 在 C 语言中，我们可以通过比较运算符（如\==、!=、<、>、<=、>=）来对指针进行关系运算。例如，我们可以比较两个指针变量是否相等（\==或!=），或者判断一个指针是否小于（<）、大于（>）或等于（\==）另一个指针 在比较时允许右边越界, 不许左边越界 |

## 指针和数组

> - 数组名绝大部分情况下是首元素的地址

|                |                                                                                                                                             |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| &数组名        | 1. 数组名不是首元素的地址<br>2. 数组名表示整个数组<br>3. &数组名取出的是整个数组的地址<br>4. 步长不同<br>5. &数组名 +1 跳过的是整个数组大小 |
| sizeof(数组名) | 1. 数组名表示的整个数组<br>2. sizeof(数组名) 计算的是整个数组的大小<br>3. 单位是字节                                                        |

## 二级指针

> 二级指针是指向指针的指针，它用于存放二级指针的变量称为二级指针变量。
> 这样就有多级指针, 一层一层指向

## 指针数组

> 存放指针的数组
> ![[Pasted image 20250513152035.png]]

---

# 初识结构体

> 结构是一些值的集合，这些值称为成员变量.结构的每个成员可以是不同类型的变量

## 结构声明

> 最基础的结构体如下

```c
struct tag
{
	member-list;
}variabe-list;
```

```c
struct Person
{
    char name[50];
    int age;
    float height;
} p1, p2; // 定义结构体的同时声明变量 p1 和 p2

// 之后可以使用 struct Person 类型声明更多变量
struct Person p3;
```

|            |              |
| ---------- | ------------ |
| struct     | 结构体关键字 |
| tag        | 结构体标签   |
| struct tag | 结构体类型   |

> 定义为一个类型的结构体如下

```c
typedef struct Person
{
    char name[50];
    int age;
} Person; // 现在可以直接用 Person 作为类型名

// 直接使用简化后的类型名声明变量
Person p;
```

> - 结构的成员可以是标量、数组、指针，甚至是其他结构体

## 初始与访问结构体

> 访问结构体成员分别用 . 或 ->

```c
typedef struct Stu
{
    char name[20];
    short age;
    char tele[12];
    char sex[5];
}Stu;
```

> 通过 `typedef` 为 `struct Stu` 类型起别名 `Stu`，后续可直接用 `Stu` 定义该结构体类型的变量

1. **`.` 操作符（用于结构体变量）**：

```c
void Print1(Stu tmp)
{
    printf("name: %s\n", tmp.name);
    printf("age: %d\n", tmp.age);
    printf("tele: %s\n", tmp.tele);
    printf("sex: %s\n", tmp.sex);
}
```

> `Print1` 函数接收 `Stu` 类型的变量 `tmp`，通过 `tmp.成员名`（如 `tmp.name`）直接访问结构体变量的成员。其中 `tmp` 是拷贝的一个临时值

2. **`->` 操作符（用于结构体指针）**：

```c
void Print2(Stu* ps)
{
    printf("name: %s\n", ps->name);
    printf("age: %d\n", ps->age);
    printf("tele: %s\n", ps->tele);
    printf("sex: %s\n", ps->sex);
}
```

> `Print2` 函数接收 `Stu*` 类型的指针 `ps`，通过 `ps->成员名`（如 `ps->name`）访问结构体指针所指向的成员。如果做出修改则是在本体上修改

# 大小端存储

> - 大端 (存储) 模式
> 是指数据的低位保存在内存的高地址中
> 而数据的高位，保存在内存的低地址中

> - 小端 (存储) 模式
> 是指数据的低位保存在内存的低地址中
> 而数据的高位，保存在内存的高地址中

# 数据在内存中的存储

## 整数家族

> 有符号和无符号数

## 浮点型

> 常见的浮点数 3.14159 1E10 浮点数家族包括：float、double、long double 类型。浮点数表示的范围:float.h 中定义

# 详解指针

## 基础知识

> 1.指针就是个变量，用来存放地址，地址唯一标识一块内存空间
>
> 2.指针的大小是固定的 4/8 个字节 (32 位平台/64 位平台)
>
> 3.指针是有类型，指针的类型决定了指针的 +- 整数的步长，指针解引用操作的时候的权限
>
> 4.指针的运算

## 字符指针

> 常量字符串不能修改
![[Pasted image 20250513155030.png]]

## 指针数组

> 存放指针变量的数组, 可以用于存储另外数组的首地址, 就可以找到该数组

## 数组指针

> 把数组的地址给一个指针存放

```c
int *p = NULL; // p是整形指针 - 指向整形的指针 - 可以存放整形的地址  

char* pc = NULL; // pc是字符指针 - 指向字符的指针 - 可以存放字符的地址 

// 数组指针 - 指向数组的指针 - 存放数组的地址  

int arr[10] = {0};  

arr - 首元素地址  

&arr[0] - 首元素的地址  

&arr - 数组的地址  
```
