# Common UI 基础使用

> [!info] 文档相关
> Common UI 最基础的使用教程, 包括配置输入, Common UI 控件介绍, Common UI 堆栈/队列使用

## 使用原生输入

> 其中全局输入的配置几乎全在**项目设置**内, 所以需要按照所需条目配置.
> 记得使用 `SetInputMode` 函数控制输入模式

1. 项目设置内的 `InputData` 选项

	> ![[Pasted image 20250427112318.png]]  
	> 内容类似于上图  
	> 需要 `DataAsset`  
	> ![[Pasted image 20250427113341.png]]  
	> 用于配置按键信息

2. 平台设置内的 `ControllerData` 选项

	> **用于配置各个不同平台的输入控制器**  
	> 使用 `ControllerDataAsset` 再重新配置一遍类似于 `DataAsset` 的按键信息  
	> ![[Pasted image 20250427114801.png]]

3. 应用能正常使用全局 UI 输入了, 例如返回和确认 (需要在 WBP 内勾选 `IsBack`)

## 使用增强输入

> 使用 `EnhanceInputComponent` 组件配合 `CommonUI` 的输入
> 其原理就是使用 `IMC` 注册全局输入响应, 在通过 `泛型事件` 判断是否为 UI 输入事件还是 Gameplay 输入事件

1. 勾选使用增强输入支持
2. 项目设置内的 `InputData` 选项, 不需要使用 `DataTable` 转而填入 `IA` 资产
3. 对于 `IA` 资产需要使用一个 `MetaDataTables` 来管理所有 `IA` 的全部元数据
4. 还是需要平台设置内的 `ControllerData` 选项
5. 最好使用 `PlayerController` 或者其他的地方添加 `UI专用的IMC`
6. 也可以在 `ActivatableUserWidget` 中的细节面板添加 `IMC` 在 `Widget` 的启用/禁用下, 可以自动的添加/移除 `IMC`

> 按照上文配置数据 ==如果其中想要通过 UI 使用增强输入事件的话, 需要重载 `GetInputConfig` 函数, 将其输入模式设置为 All==

# 通用风格

使用各种共享的 `Style` 数据蓝图实现, 统一的风格
![[Pasted image 20250427173306.png]]
其中每个样式, 都类似于原生 `UMG` 拥有类似的调节选项

# 可激活控件

可在其生命周期内被 " `激活` " 和 " `停用` "，且无需进行其他修改或销毁的部件基类。

通常，这样做是为了满足以下一个或多个目的：
- 该部件可以在不脱离层级结构（或不重建底层 `SWidgets`）的情况下开启 / 关闭，因此仅使用 `Construct`/`Destruct` 方法是不够的。
- 你希望能够从该部件 " `返回` "，这可能意味着返回面包屑导航、关闭模态框或其他操作。此功能已内置在此处。
- 该部件在层级结构中的位置使其成为可激活部件树中有意义的节点，输入将通过该节点路由到所有部件。

默认情况下，可激活部件：
- 构造时不会自动激活。
- 不会注册接收返回操作（实际上也不会接收任何其他操作）。
- 如果被归类为返回处理程序，当接收到返回操作时，它将自动停用（但不会被销毁）。

请注意，将可激活部件从 UI 中移除（即触发 `Destruct()`）将始终使其停用，即使 `UWidget` 未被销毁。
只有在启用自动激活的情况下，重建底层 `SWidget` 才会导致重新激活。

# 可激活控件堆栈/队列

## 队列 (`Queues`)

可激活部件元素的显示队列。

- 一次仅一个部件处于激活 / 显示状态，队列中的其他所有部件均处于停用状态。
- 当激活的部件停用时，它会自动从部件中移除，放回对象池，并且队列中的下一个部件（如果有）将被显示。

## 堆栈 (`Stacks`)

可激活部件元素的显示栈。

- 只有栈顶的部件会被显示和激活，其他所有部件都会被停用。
- 当栈顶显示的部件停用时，它会被自动移除，前一个条目将被显示 / 激活。
- 如果提供了 `Root` 内容，无论激活状态如何，它永远不会被移除。

> 未拓展的情况下, 以上两个面板暴露到蓝图函数如下:
>
> > 1. `GetActiveWidget()` 获取当前栈顶的控件 `Ptr`
> > 2. `ClearWidgets()` 清除子控件
> > 3. `SetTransitionDuration(float Duration)`/`GetTransitionDuration()` 设置/获取过渡持续时间
> > 4. `Push Widget()` 添加子控件到栈顶
> > 5. `RemoveWidget(UCommonActivatableWidget* WidgetToRemove)` 根据 `Ptr` 移除控件

**如未覆盖到使用场景, 请自定义函数**
建议自己构造一个出栈的快捷函数

**Tips: 如果需要使用输入, 或者控制流程的控件, 建议使用可激活控件**
