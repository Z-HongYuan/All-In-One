# UE 蓝图

## Tick 的进阶用法

### 帧间隔 (间隔多少帧数)

- 当间隔多少帧才执行一段逻辑
![[Pasted image 20250516150643.png]]

1. **核心思想**
利用一个整型计数器（`Tick Index`）在每帧自增，并在达到预设阈值时触发一次目标逻辑，然后重置计数器，从而实现 " 每 N 帧执行一次 " 功能。
2. **实现流程**
- **计数累加**
    - 在 `Event Tick` 中，每次进入先判断 `Tick Index < N`。
    - 若小于阈值，则执行 `++Tick Index`，不触发主要逻辑。
- **阈值判断与执行**
    - 当 `Tick Index >= N` 时，走到分支的 "True" 端，执行一次目标逻辑（比如打印、调用函数等）。
    - 随后立即 `Set Tick Index = 0`，为下一轮间隔重新计数。

3. **优点**
	- **精确控制频率**：可根据需要任意设定阈值 N，精确地在第 N 帧执行一次。
	- **轻量无额外依赖**：只需一个整型变量和一个分支节点即可实现，无需插件或复杂系统。
	- **易于调试**：通过打印或可视化节点，实时监控计数器状态与触发时机。

4. **适用场景**
	- 周期性但不需每帧都运行的逻辑：如每隔若干帧采样一次数据、更新低频动画状态、限频发送网络请求等。
	- 性能敏感场合：将高成本操作均摊到多帧中，避免多次重复开销。

5. **扩展优化建议**
- **使用枚举或宏常量替代 " 魔法数 "**
    - 把阈值 N（如 10）定义成命名常量或枚举项，提高可读性与可维护性。
- **动态阈值调整**
    - 根据运行时性能或目标帧率动态修改 N，例如在帧率下降时自动延长间隔。
- **抖动与随机化**
    - 若多个系统同时以固定间隔执行，可能产生 " 集中触发 " 导致帧峰值，可在阈值上加微小随机偏移，打散执行时机。
- **替代方案**
    - 对于更复杂的节拍控制，可考虑使用 UE 的 `FTicker` 系统或 `Timer Manager`，直接以秒为单位注册回调，无需手动计数帧数。

6. **总结**：
" 帧间隔 " 是一种简单高效的限频执行模式，通过最少的节点和变量即可实现每 N 帧触发一次逻辑。对于低频、周期性需求，能有效分摊开销、保持代码清晰；在需要更精准或更灵活的定时机制时，可结合 UE5 自带的定时器/FTicker 等高级接口。

### 帧队列 (基于 Tick 的状态机)

- 顺序执行一段任务
![[Pasted image 20250516151320.png]]

1. **核心思想**
    - 将一整段复杂逻辑拆分成若干子任务（段落），并在连续的 `Tick` 调用中依次执行每一小段，以平滑分摊每帧的计算开销。
        
2. **实现流程**
    1. 定义一个整型或枚举型状态变量（图中为 `Tick Index`）。
    2. 在每次 `Event Tick` 中，通过 `Switch on Int`（或 `Switch on Enum`）根据状态值跳转到对应的子任务执行入口。
    3. 在每个子任务逻辑末尾，更新状态变量为下一段逻辑所对应的值。
    4. 最后一段逻辑执行完成后，可将状态重置为初始值（结束循环）或指向某个循环段，实现持续或一次性执行。
        
3. **优点**
    - **分摊性能开销**：避免一次性在单帧内执行大量操作，减少卡顿风险。
    - **流程可控**：清晰地管理各段逻辑的执行顺序和循环/终止条件。
    - **易于扩展**：只需增减 `Switch` 支持的分支和对应的子任务，即可灵活调整流程。
        
4. **扩展建议**
    - 将整型 `Flag` 替换为自定义枚举（`Enum`），提高可读性和可维护性。
    - 在每段逻辑开始前，加入超时或跳过检查，以在特殊情况下提前终止或跳转。
    - 对于各子任务的执行时长，可动态监测并根据帧率自动调整每帧最大执行段数，进一步优化性能。

**总结**：
帧队列（Frame Queue）模式本质上是一种基于 `Tick` 的 " 轻量级状态机 "，通过拆分、排队和循环方式，将大块逻辑分散到多帧执行中，从而获得更加平滑和可控的运行效果。

### 帧延迟 (间隔多少时间)

- 经过多少现实时间才执行逻辑
![[Pasted image 20250516154254.png]]

- **原理**：每帧通过 `Get World Delta Seconds`（即上一帧所用时间，秒）累加到浮点变量 `ElapsedTime`，当 `ElapsedTime >= TargetTime` 时触发逻辑并将 `ElapsedTime` 减去或重置为 0 ，实现基于真实时间的延迟控制
    
- **优势**：完全与帧率无关，无论 30 FPS 还是 120 FPS，触发间隔都严格按秒数计算，保证行为一致性
    
- **简要实现**：
    
    1. 事件 Tick → 获取 `Delta Seconds` → `ElapsedTime += DeltaSeconds`
        
    2. 判断 `ElapsedTime >= TargetTime` → 真则执行逻辑并 `ElapsedTime -= TargetTime`（保留溢出）

### 帧位移 (时间驱动运动)

- 使用场景差量 * 速率来设置位置, 以达到无关帧率的位移
![[Pasted image 20250516154935.png]]

- 使用 **Delta Time**：每帧获取上一帧到当前帧的真实时间增量（`deltaTime`），并用它来计算位移：

    ```c++
    Position += Velocity × deltaTime 
    ```

    这样就完成了 **显式欧拉积分**（Explicit Euler Integration），保证每帧按真实时间推进位移。
    
- **帧率无关**：由于乘以了 `deltaTime`（秒），无论是在 30 FPS 还是 120 FPS 下，单位时间内的总移动距离始终相同，消除了因帧率波动带来的快慢差异。
    
- **实现简洁**：只需在 `Event Tick` 中：
    1. 调用 `Get World Delta Seconds` 获取 `deltaTime`
    2. 将 `Velocity * deltaTime` 累加到当前位置
		即可在蓝图或代码里轻松完成帧率无关的平滑运动。
